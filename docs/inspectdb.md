# Inspect DB

Does it happen often changing ORMs during a project? Well, not that often really but it might
happen and usually during the discovery time where the best stack is being *figured*.

Well, something that usually remains is the SQL database and what it changes is normally the ORM
that operates on the top of it.

The `inspectdb` is another client management tool that allows you to read from an existing database
all the tables and generates [ReflectModel](./reflection.md) objects for your.

In other words, it maps existing database tables into an **Edgy like syntax** to make your life
easier to manage.

!!! Tip
    If you are not familiar with [ReflectModel](./reflection.md), not is is a good time to catch-up.

## Side note

Before reading this section, you should get familiar with the ways Edgy handles the [discovery](./migrations/discovery.md#auto-discovery) of the applications.

The following example will be using a clean and simple way but if you already have an application
and want to take advantage of the [discovery](./migrations/discovery.md#auto-discovery) of the applications
that is also possible.

## Reflect models

These are the models automatically generated by **Edgy** when the `inspectdb` is triggered.

The reason for the [ReflectModel](./reflection.md) it is simply because those are not managed by
the [migration system](./migrations/migrations.md) **but you still operate as a normal [Edgy model](./models.md)**.

In other words, it is a *safety measure* of **Edgy**.

## How does it work

Now it is time for the good stuff right? Well, there are two ways of doing this.

* Via [database url](#database-url).
* Via [application registry](#via-application-registry).

### Database url

This is the easiest and probably the one way you will be using all the time and syntax is as simple as this:

```shell
edgy inspectdb --database <CONNECTION-STRING> > <NAME-OF-FILE>.py
```

**Example**

```shell
edgy inspectdb --database "postgres+asyncpg://user:password@localhost:5432/my_db" > models.py
```

And that is it! This simple. The `inspectdb` will write the models inside the specified file and
from there you can use them anywhere.

#### Parameters

To check the available parameters for the `inspectdb`:

```shell
edgy inspectdb --help
```

* **schema** - The name of the schema to connect. For example, in `MSSQL` the `dbo` is usually used.
This will be probably used on rare occasions by it is available just in case you need.
* **database** - The fully qualified connection string to the database. Example:
`postgres+asyncpg://user:password@localhost:5432/my_db`.

### Via application registry

Well, if you are familiar with the [discovery](./migrations/discovery.md#auto-discovery) of the
application, then this will be easier.

When the `--database` is not provided, the **discovery**  will try to find your application and also
a [Migration](./migrations/migrations.md#migration) or an [EdgyExtra](./extras.md#edgyextra) object
and in the end extracts the connection string for the `inspectdb`.

**Example**

Imagine the following folder and file structure:

```shell hl_lines="16" title="myproject"
.
├── Makefile
└── myproject
    ├── __init__.py
    ├── apps
    │   ├── __init__.py
    ├── configs
    │   ├── __init__.py
    │   ├── development
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── settings.py
    │   └── testing
    │       ├── __init__.py
    │       └── settings.py
    ├── main.py
    ├── tests
    │   ├── __init__.py
    │   └── test_app.py
    └── urls.py
```

Inside the root folder, run:

```shell
edgy inspectdb > models.py
```

If you have a `Migration` or `EdgyExtra` object somewhere in the root or first level folder, then
Edgy will find it and extract the connection string.
